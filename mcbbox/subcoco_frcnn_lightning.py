# AUTOGENERATED! DO NOT EDIT! File to edit: 30_subcoco_frcnn_lightning.ipynb (unless otherwise specified).

__all__ = ['FRCNN', 'save_final']

# Cell
import json, os, requests, sys, tarfile
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import numpy as np
import pickle
import random

from collections import defaultdict
from functools import reduce
from IPython.utils import io
from pathlib import Path
from PIL import Image
from PIL import ImageStat

from pycocotools.coco import COCO
from pycocotools.cocoeval import COCOeval
from tqdm import tqdm
from typing import Hashable, List, Tuple, Union

# Cell
import albumentations as A
import pytorch_lightning as pl
import torch, torchvision
import torch.nn.functional as F
import torch.multiprocessing
from pytorch_lightning import LightningDataModule, LightningModule, Trainer
from torch import nn
from torch.nn.modules import module
from torch import optim
from torch.utils.data import DataLoader, random_split
from torchvision.models.detection import FasterRCNN
from torchvision.models.detection.rpn import AnchorGenerator
from torchvision.models.detection.faster_rcnn import FastRCNNPredictor
from .subcoco_utils import *
from .subcoco_lightning_utils import *

torch.multiprocessing.set_sharing_strategy('file_system')
print(f"Python ver {sys.version}, torch {torch.__version__}, torchvision {torchvision.__version__}, pytorch_lightning {pl.__version__}")

if is_notebook():
    from nbdev.showdoc import *

# Cell
class FRCNN(AbstractDetectorLightningModule):
    def __init__(self, **kwargs):
        AbstractDetectorLightningModule.__init__(self, **kwargs)

    def create_model(self, backbone_name, num_classes=1, **kwargs):
        model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)
        self.in_features = model.roi_heads.box_predictor.cls_score.in_features
        # replace the pre-trained head with a new one, which is trainable
        model.roi_heads.box_predictor = FastRCNNPredictor(self.in_features, self.num_classes+1)

        # Hacked to avoid model builtin call to GeneralizedRCNNTransform.normalize() as done in augmentation
        def noop_normalize(image): return image

        # Hacked to avoid model builtin call to GeneralizedRCNNTransform.resize() as done in augmentation
        def noop_resize(image, target): return image, target

        # HACK!! IceVision does this too!
        model.transform.normalize = noop_normalize
        model.transform.resize = noop_resize

        return model

    def get_main_model(self): return self.model

    def get_head(self):  return self.model.roi_heads

    def get_backbone(self): return self.model.backbone

# Cell
def save_final(frcnn_model, model_save_path):
    torch.save(frcnn_model.model.state_dict(), model_save_path)